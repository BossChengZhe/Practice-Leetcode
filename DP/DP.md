> ## [面试题46.将数字翻译为字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)<br>
&emsp;&emsp;由题目可知，每一位数字单独翻译都是可以的，但当两位数字组合的时候，并不是每一对都可以被翻译为字母的，因为我们知道，一共只有26个英文字母，所以组合数$x$, <small>$10\leq x\leq 25$</small>，故需要判断。<br>
&emsp;&emsp;本题利用DP的原理，递推公式为，分成两种情况讨论
$$f(i)=f(i-1)+f(i-2)[i-1\geq 0,10\leq x\leq 25]$$
* 当第$i$个数字单独翻译时，就等于$f(i-1)$每一个翻译后的字符串加上第$i$个数字对应的字符翻译，而单个字符的翻译是肯定有效的，于是直接加上$f(i-1)$
* 当第$i$、$i-1$个字符在一起翻译，就需要检测当前数字的合理性，如果超出25或者小于两位数的最小值10都是无效的翻译，所以$x$必须在$[10,25]$范围内的

&emsp;&emsp;如上两种情况就得到了DP的递推公式

> ## [32.最长有效括弧](https://leetcode-cn.com/problems/-valid-parentheses/)
&emsp;&emsp;首先由有效括号的性质可以得到，有效括号都是由')'结尾的，所以以'('结尾的字符串都不是有效括号，所以可以采取分类讨论和动态规划的方式，解此问题，(`dp[i]`是以`i`结尾的有效括号的长度)
* 当`s[i]==')'&&s[i-1]=='('`时，即括号形式是"....()"，`dp[i]=dp[i-2]+2`<small>($x-2 \ge 0$)</small>
* 当`s[i]==')'&&s[i-1]==')'&&s[i-dp[i-1]-1]=='('`时,即括号形式是"...))"，`dp[i]=dp[i-1]+dp[i-dp[i-1]-2]+2`<small>($i-dp[i-1]-2 \ge 0$)</small>
    > `i-dp[i-1]-2`、`i-dp[i-1]-1`分别代表了什么，是当前动态规划的核心
> ## [70.爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)
&emsp;&emsp;这题解题思路有两条，第一条是递归的方法，第二条就是动态规划
* 递归的方法说来很简单，就是遍历在当前步长后遍历走1步和走2步之后所有的情况，但是由于重复的太多，导致时间复杂度很高，最后时间超限
* 当$n>2$时，最后一次走两步和走一步分别对应着`dp[n-2],dp[n-1]`，然后就得到了动态规划的递推公式，初始化`dp[1]=1,dp[2]=2`，然后就按照递推公式计算直到`dp[n]`
$$dp[i]=dp[i-2]+dp[i-1]$$

> ## [139.单词拆分](https://leetcode-cn.com/problems/word-break/)
&emsp;&emsp;单词拆分问题可以很轻易的拆解为当前单词与前面单词结果的结合，比如我遍历到`"leetcode"`中的`"code"`，经过查找，发现在词典中，于是我们查找之前，`dp[i-4]`看是否有效，有效当前为`true`，否则为`false`
&emsp;&emsp;当然查询也可以用其他的方法查，我用二分只是因为我只能想出二分的查找方式。

> ## [718.最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)
&emsp;&emsp;DP的话，需要确定`dp[i][j]`代表的什么意思，在本题中表示在以`A[i]`和`B[j]`结尾的数组 `A`和 `B`前缀的最大公共后缀，那么状态转移公式就可以写为 
```C++
dp[i][j] = (A[i-1] ==  B[j-1]) ? dp[i - 1][j - 1] + 1 : 0;
```
&emsp;&emsp;需要注意的是，对于范围内任意`i`,`j`，`dp[i][j]`的值和其左上角的值有关，那么我们需要额外在原有的基础上加上一层数据，保证数组不越界，这也是代码中`dp`数组会在`A.size()`和`B.size()`上加1的原因。

> ## [53.最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)
&emsp;&emsp;每一个数组中元素只有两种情况，一个是在当前子序列和中，一个是不在，只需要判断该数前面的序列和加上该数与该数对比，取较大的那个。由于结果之和最后一个结果有关，所以只需要设置两个变量，达到$O(1)$空间占用。
$$f(i)=max(pre+nums_{i},nums_{i})$$

> ## [44.通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)
&emsp;&emsp;可以分解为前缀子序列的匹配子问题，当前状态与前面匹配状态相关，所以可以采用动态规划解题。
* 当匹配模式是字母时，并且与当前指向的字符相同时，<small>$dp_{i,j}=dp_{i-1,j-1}$</small>
* 当前匹配模式是"?"时，可以匹配任意字符，<small>$dp_{i,j}=dp_{i-1,j-1}$</small>
* 当前匹配模式指向的是"\*",那么有两种情况，一个是使用这个“\*”,那么 <small>$dp_{i,j}=dp_{i-1,j}$</small>;第二种情况是没有使用“\*”匹配字符串，那么 <small>$dp_{i,j}=dp_{i,j-1}$</small>
* 当然我们也需要注意边界情况，也就是字符串是否为空和匹配模式是否为空两个变量共四种情况分类讨论
    * 首先两者都不为空，需要计算得到
    * 字符串不为空，匹配模式为空，空的匹配模式不能匹配非空字符串，所以所有的 <small>$dp_{i,0}=false \quad 0<i \le size_j$</small>
    * 字符串为空，匹配模式不为空，只有"\*"可以匹配空字符串，需要匹配模式全部为"\*"时，才可以使得 <small>$dp_{0,j}=true \quad 0<j\le size_{p}$</small>
    * 全为空，即 <small>$dp_{0,0}=true$</small>

> ## [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)
&emsp;&emsp;观察地图可以得到，由于机器人只能向下或者向上走，那么该位置的走法只跟当前位置的左边或者是右边有关系，那么一个就分解成为子问题，那么可以采用动态规划解该题
$$dp_{i,j}=dp_{i-1,j}+dp_{i,j-1}$$

> ## [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)
&emsp;&emsp;观察地图可以得到，由于机器人只能向下或者向上走，当前位置如果不存在障碍物，那么该位置的走法只跟当前位置的左边或者是右边有关系，那么一个就分解成为子问题，那么可以采用动态规划解该题 
$$dp_{i,j}=dp_{i-1,j}+dp_{i,j-1} \quad if\quad obstacleGrid_{i,j}==1$$
**暴力解法**害死人，如果采用递归的方式计算，时间超限！！！
