>  ## [26.删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)<br>
&emsp;&emsp;这题思路相当简单，但是是原地改变数组，我们如果`vector.earse()`方法会改变数组的大小迭代器用不了，那么只能将非重复的数往前‘挪’，但是为了加快程序运行速度，可以直接将采用双指针的方法，$i$、$j$两个指针，其中$i$得到的重复数组，而$j$是遍历数组的指针，碰到`nums[i]!=nums[j]`时，`i++`并`nums[i]=nums[j++]`，经过这两步就可以实现将非重复的元素移到前面，随后使用`vector.pop()`删去最后$j-i$个元素。

>  ## [27.移除元素](https://leetcode-cn.com/problems/remove-element/)<br>
&emsp;&emsp;思路与26大差不离，也是利用双指针，$i$、$j$两个指针，只有初始值的不同，和$i$移动的方式不同而已

> ## [1300.转变数组后最接近目标值的数组和](https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/)
&emsp;&emsp;由数学性质，可以很轻松的推出，当当前数组的元素之和小于`target`时，是不需要转变数组的，即返回当前数组最大值，由于要求求和结果尽可能小并且结果可能并不是当前数组中的值，所以先对目标数组排序后，从左到右遍历(此处用**二分查找应该更快**，懒癌晚期)找到`i`使得`arr[0]+...+arr[i]>target`，则整数`value`的值就在`arr[i-1]`~`arr[i]`之间，在对这个区间进行二分查找，同时记录下$|sum-target|$，当二分查找结束后，即可得到当前`value`
