> ## [297.二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)
&emsp;&emsp;由于二叉树的遍历方式有很多，前序中序后序遍历，还有什么层次遍历，我是用的前序遍历得到的结果(应该是我的写法问题，成绩很差)
* 编码部分：我采用的是前序遍历，如果当前节点不为空，则将`node->val`填入字符串中，然后递归遍历左子树和右子树；如果当前节点为空，填入n，表示该节点为空。
* 解码部分：思路就是遍历的逆，如果读取字符串，得到当前`val`是`n`，则当前节点是空节点返回`NULL`，否则新建节点，并递归左子树和右子树。

> ## [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)
&emsp;&emsp;建立二叉搜索树首先要明白二叉搜索树的原理，对于每个节点来说，左子树节点的值比当前值要小，右子树节点的值要比当前节点大。基于此条性质我们可以每次在建立一个新的二叉搜索树时，采用中值作为根节点，左半部分作为左子树节点的值递归，右半部分作为右子树的值递归建立，得到可能的二叉搜索树。

> ## [112.路径总和](https://leetcode-cn.com/problems/path-sum/)
&emsp;&emsp;递归解法，
* 如果当前节点左右孩子均为空，说明此节点是叶子节点，比较当前`num`值和叶子节点是否相等，如果相等的话，返回`true`，否则返回`false`；
* 如果当前节点为空，说明已经到达了叶子节点的左右孩子或者兄弟；
    * 如果是叶子节点的左右兄弟，那么没有在叶子节点返回，说明这条根到路径的和跟`num`不相等，所以返回`false`
    * 如果是叶子节点的左右兄弟，这条路径根本不符合条件，返回`false`
* 不属于以上两种情况，即中间节点，递归寻找左右子树；